# Gemini CLI コア: ツール API

Gemini CLI コア (`packages/core`) は、ツールを定義、登録、実行するための堅牢なシステムを備えています。これらのツールは Gemini モデルの機能を拡張し、ローカル環境との対話、Web コンテンツの取得、単純なテキスト生成以外のさまざまなアクションの実行を可能にします。

## コアコンセプト

- **ツール (`tools.ts`):** すべてのツールの契約を定義するインターフェイスとベースクラス (`BaseTool`)。各ツールには次のものが必要です。

  - `name`: 一意の内部名 (Gemini への API 呼び出しで使用されます)。
  - `displayName`: ユーザーフレンドリーな名前。
  - `description`: ツールが何をするかの明確な説明。Gemini モデルに提供されます。
  - `parameterSchema`: ツールが受け入れるパラメータを定義する JSON スキーマ。これは、Gemini モデルがツールを正しく呼び出す方法を理解するために重要です。
  - `validateToolParams()`: 受信したパラメータを検証するメソッド。
  - `getDescription()`: 実行前に特定のパラメータでツールが何をするかの人間が読める説明を提供するメソッド。
  - `shouldConfirmExecute()`: 実行前にユーザーの確認が必要かどうかを判断するメソッド (潜在的に破壊的な操作など)。
  - `execute()`: ツールのアクションを実行し、`ToolResult` を返すコアメソッド。

- **`ToolResult` (`tools.ts`):** ツールの実行結果の構造を定義するインターフェイス:

  - `llmContent`: コンテキストのために LLM に送り返される履歴に含まれる事実に基づく文字列コンテンツ。
  - `returnDisplay`: CLI に表示するためのユーザーフレンドリーな文字列 (多くの場合 Markdown) または特別なオブジェクト (FileDiff など)。

- **ツールレジストリ (`tool-registry.ts`):** 次の責任を負うクラス (`ToolRegistry`):
  - **ツールの登録:** 利用可能なすべての組み込みツール (例: `ReadFileTool`、`ShellTool`) のコレクションを保持します。
  - **ツールの検出:** ツールを動的に検出することもできます。
    - **コマンドベースの検出:** `toolDiscoveryCommand` が設定で構成されている場合、このコマンドが実行されます。カスタムツールを記述した JSON を出力することが期待されており、その後 `DiscoveredTool` インスタンスとして登録されます。
    - **MCP ベースの検出:** `mcpServerCommand` が構成されている場合、レジストリはモデルコンテキストプロトコル (MCP) サーバーに接続してツールを一覧表示および登録できます (`DiscoveredMCPTool`)。
  - **スキーマの提供:** 登録されているすべてのツールの `FunctionDeclaration` スキーマを Gemini モデルに公開し、利用可能なツールとその使用方法をモデルが認識できるようにします。
  - **ツールの取得:** コアが実行のために名前で特定のツールを取得できるようにします。

## 組み込みツール

コアには、通常 `packages/core/src/tools/` にある、事前定義されたツールスイートが付属しています。これらには次のものが含まれます。

- **ファイルシステムツール:**
  - `LSTool` (`ls.ts`): ディレクトリの内容を一覧表示します。
  - `ReadFileTool` (`read-file.ts`): 単一ファイルの内容を読み取ります。絶対パスである必要がある `absolute_path` パラメータを取ります。
  - `WriteFileTool` (`write-file.ts`): ファイルにコンテンツを書き込みます。
  - `GrepTool` (`grep.ts`): ファイル内のパターンを検索します。
  - `GlobTool` (`glob.ts`): glob パターンに一致するファイルを検索します。
  - `EditTool` (`edit.ts`): ファイルのインプレース変更を実行します (多くの場合、確認が必要です)。
  - `ReadManyFilesTool` (`read-many-files.ts`): 複数のファイルまたは glob パターンからコンテンツを読み取って連結します (CLI の `@` コマンドで使用されます)。
- **実行ツール:**
  - `ShellTool` (`shell.ts`): 任意のシェルコマンドを実行します (慎重なサンドボックス化とユーザーの確認が必要です)。
- **Web ツール:**
  - `WebFetchTool` (`web-fetch.ts`): URL からコンテンツを取得します。
  - `WebSearchTool` (`web-search.ts`): Web 検索を実行します。
- **メモリツール:**
  - `MemoryTool` (`memoryTool.ts`): AI のメモリと対話します。

これらの各ツールは `BaseTool` を拡張し、特定の機能に必要なメソッドを実装します。

## ツール実行フロー

1.  **モデルリクエスト:** Gemini モデルは、ユーザーのプロンプトと提供されたツールスキーマに基づいて、ツールの使用を決定し、その応答で `FunctionCall` 部分を返します。ツール名と引数を指定します。
2.  **コアがリクエストを受信:** コアはこの `FunctionCall` を解析します。
3.  **ツールの取得:** `ToolRegistry` で要求されたツールを検索します。
4.  **パラメータの検証:** ツールの `validateToolParams()` メソッドが呼び出されます。
5.  **確認 (必要な場合):**
    - ツールの `shouldConfirmExecute()` メソッドが呼び出されます。
    - 確認の詳細を返す場合、コアはこれを CLI に伝え、CLI はユーザーにプロンプトを表示します。
    - ユーザーの決定 (続行、キャンセルなど) がコアに送り返されます。
6.  **実行:** 検証および確認された場合 (または確認が不要な場合)、コアは提供された引数と `AbortSignal` (潜在的なキャンセルのため) を使用してツールの `execute()` メソッドを呼び出します。
7.  **結果の処理:** `execute()` からの `ToolResult` がコアによって受信されます。
8.  **モデルへの応答:** `ToolResult` の `llmContent` は `FunctionResponse` としてパッケージ化され、ユーザー向けの応答を生成し続けることができるように Gemini モデルに送り返されます。
9.  **ユーザーへの表示:** `ToolResult` の `returnDisplay` が CLI に送信され、ツールが何をしたかをユーザーに表示します。

## カスタムツールによる拡張

ユーザーによる新しいツールの直接的なプログラムによる登録は、一般的なエンドユーザー向けの提供ファイルでは主要なワークフローとして明示的に詳述されていませんが、アーキテクチャは次による拡張をサポートしています。

- **コマンドベースの検出:** 上級ユーザーまたはプロジェクト管理者は、`settings.json` で `toolDiscoveryCommand` を定義できます。このコマンドは、Gemini CLI コアによって実行されると、`FunctionDeclaration` オブジェクトの JSON 配列を出力する必要があります。コアはその後、これらを `DiscoveredTool` インスタンスとして利用可能にします。対応する `toolCallCommand` は、これらのカスタムツールを実際に実行する責任があります。
- **MCP サーバー:** より複雑なシナリオでは、1 つ以上の MCP サーバーをセットアップし、`settings.json` の `mcpServers` 設定を介して構成できます。Gemini CLI コアは、これらのサーバーによって公開されているツールを検出して使用できます。前述のように、複数の MCP サーバーがある場合、ツール名は構成のサーバー名でプレフィックスが付けられます (例: `serverAlias__actualToolName`)。

このツールシステムは、Gemini モデルの機能を拡張するための柔軟で強力な方法を提供し、Gemini CLI をさまざまなタスクに対応する多目的なアシスタントにします。