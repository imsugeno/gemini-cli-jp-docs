# Gemini CLI を使用した MCP サーバー

このドキュメントでは、Gemini CLI でモデルコンテキストプロトコル (MCP) サーバーを構成および使用するためのガイドを提供します。

## MCP サーバーとは何ですか？

MCP サーバーは、モデルコンテキストプロトコルを介して Gemini CLI にツールとリソースを公開するアプリケーションであり、外部システムやデータソースと対話できるようにします。MCP サーバーは、Gemini モデルとローカル環境または API などの他のサービスとの間のブリッジとして機能します。

MCP サーバーを使用すると、Gemini CLI は次のことが可能になります。

- **ツールの検出:** 標準化されたスキーマ定義を介して、利用可能なツール、その説明、およびパラメータを一覧表示します。
- **ツールの実行:** 定義された引数で特定のツールを呼び出し、構造化された応答を受信します。
- **リソースへのアクセス:** 特定のリソースからデータを読み取ります (ただし、Gemini CLI は主にツールの実行に重点を置いています)。

MCP サーバーを使用すると、Gemini CLI の機能を拡張して、データベース、API、カスタムスクリプト、または特殊なワークフローとの対話など、組み込み機能を超えるアクションを実行できます。

## コア統合アーキテクチャ

Gemini CLI は、コアパッケージ (`packages/core/src/tools/`) に組み込まれた高度な検出および実行システムを介して MCP サーバーと統合します。

### 検出レイヤー (`mcp-client.ts`)

検出プロセスは `discoverMcpTools()` によって調整されます。これは次のことを行います。

1. **構成済みサーバーの反復処理:** `settings.json` の `mcpServers` 構成から構成済みサーバーを反復処理します。
2. **接続の確立:** 適切なトランスポートメカニズム (Stdio、SSE、またはストリーマブル HTTP) を使用して接続を確立します。
3. **ツール定義の取得:** MCP プロトコルを使用して各サーバーからツール定義を取得します。
4. **サニタイズと検証:** Gemini API との互換性のためにツールスキーマをサニタイズおよび検証します。
5. **ツールの登録:** 競合解決を使用してグローバルツールレジストリにツールを登録します。

### 実行レイヤー (`mcp-tool.ts`)

検出された各 MCP ツールは、次のことを行う `DiscoveredMCPTool` インスタンスにラップされます。

- **確認ロジックの処理:** サーバーの信頼設定とユーザーの好みに基づいて確認ロジックを処理します。
- **ツール実行の管理:** 適切なパラメータで MCP サーバーを呼び出してツール実行を管理します。
- **応答の処理:** LLM コンテキストとユーザー表示の両方の応答を処理します。
- **接続状態の維持:** 接続状態を維持し、タイムアウトを処理します。

### トランスポートメカニズム

Gemini CLI は、3 つの MCP トランスポートタイプをサポートしています。

- **Stdio トランスポート:** サブプロセスを生成し、stdin/stdout を介して通信します。
- **SSE トランスポート:** サーバー送信イベントエンドポイントに接続します。
- **ストリーマブル HTTP トランスポート:** 通信に HTTP ストリーミングを使用します。

## MCP サーバーのセットアップ方法

Gemini CLI は、`settings.json` ファイルの `mcpServers` 構成を使用して、MCP サーバーを検索して接続します。この構成は、さまざまなトランスポートメカニズムを持つ複数のサーバーをサポートします。

### settings.json で MCP サーバーを構成する

`~/.gemini/settings.json` ファイルでグローバルレベルで MCP サーバーを構成するか、プロジェクトのルートディレクトリで `.gemini/settings.json` ファイルを作成または開きます。ファイル内に `mcpServers` 構成ブロックを追加します。

### 構成構造

`settings.json` ファイルに `mcpServers` オブジェクトを追加します。

```json
{ ...ファイルには他の構成オブジェクトが含まれています
  "mcpServers": {
    "serverName": {
      "command": "path/to/server",
      "args": ["--arg1", "value1"],
      "env": {
        "API_KEY": "$MY_API_TOKEN"
      },
      "cwd": "./server-directory",
      "timeout": 30000,
      "trust": false
    }
  }
}
```

### 構成プロパティ

各サーバー構成は、次のプロパティをサポートしています。

#### 必須 (次のいずれか)

- **`command`** (文字列): Stdio トランスポート用の実行可能ファイルへのパス
- **`url`** (文字列): SSE エンドポイント URL (例: `"http://localhost:8080/sse"`)
- **`httpUrl`** (文字列): HTTP ストリーミングエンドポイント URL

#### 任意

- **`args`** (文字列配列): Stdio トランスポート用のコマンドライン引数
- **`env`** (オブジェクト): サーバープロセスの環境変数。値は `$VAR_NAME` または `${VAR_NAME}` 構文を使用して環境変数を参照できます。
- **`cwd`** (文字列): Stdio トランスポート用の作業ディレクトリ
- **`timeout`** (数値): ミリ秒単位の要求タイムアウト (デフォルト: 600,000ms = 10 分)
- **`trust`** (ブール値): `true` の場合、このサーバーのすべてのツール呼び出し確認をバイパスします (デフォルト: `false`)

### 構成例

#### Python MCP サーバー (Stdio)

```json
{
  "mcpServers": {
    "pythonTools": {
      "command": "python",
      "args": ["-m", "my_mcp_server", "--port", "8080"],
      "cwd": "./mcp-servers/python",
      "env": {
        "DATABASE_URL": "$DB_CONNECTION_STRING",
        "API_KEY": "${EXTERNAL_API_KEY}"
      },
      "timeout": 15000
    }
  }
}
```

#### Node.js MCP サーバー (Stdio)

```json
{
  "mcpServers": {
    "nodeServer": {
      "command": "node",
      "args": ["dist/server.js", "--verbose"],
      "cwd": "./mcp-servers/node",
      "trust": true
    }
  }
}
```

#### Docker ベースの MCP サーバー

```json
{
  "mcpServers": {
    "dockerizedServer": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "-e",
        "API_KEY",
        "-v",
        "${PWD}:/workspace",
        "my-mcp-server:latest"
      ],
      "env": {
        "API_KEY": "$EXTERNAL_SERVICE_TOKEN"
      }
    }
  }
}
```

#### HTTP ベースの MCP サーバー

```json
{
  "mcpServers": {
    "httpServer": {
      "httpUrl": "http://localhost:3000/mcp",
      "timeout": 5000
    }
  }
}
```

## 検出プロセスの詳細

Gemini CLI が起動すると、次の詳細なプロセスを通じて MCP サーバーの検出を実行します。

### 1. サーバーの反復処理と接続

`mcpServers` で構成された各サーバーについて:

1. **ステータス追跡の開始:** サーバーのステータスが `CONNECTING` に設定されます。
2. **トランスポートの選択:** 構成プロパティに基づいて:
   - `httpUrl` → `StreamableHTTPClientTransport`
   - `url` → `SSEClientTransport`
   - `command` → `StdioClientTransport`
3. **接続の確立:** MCP クライアントは、構成されたタイムアウトで接続を試みます。
4. **エラー処理:** 接続の失敗はログに記録され、サーバーのステータスは `DISCONNECTED` に設定されます。

### 2. ツールの検出

接続に成功すると:

1. **ツールの一覧表示:** クライアントは MCP サーバーのツール一覧表示エンドポイントを呼び出します。
2. **スキーマの検証:** 各ツールの関数宣言が検証されます。
3. **名前のサニタイズ:** ツール名は、Gemini API の要件を満たすようにクリーンアップされます。
   - 無効な文字 (英数字、アンダースコア、ドット、ハイフン以外) はアンダースコアに置き換えられます。
   - 63 文字を超える名前は、中央を置き換えて切り捨てられます (`___`)。

### 3. 競合の解決

複数のサーバーが同じ名前のツールを公開する場合:

1. **最初の登録が優先:** ツール名を最初に登録したサーバーが、プレフィックスなしの名前を取得します。
2. **自動プレフィックス:** 後続のサーバーには、`serverName__toolName` のようにプレフィックス付きの名前が付けられます。
3. **レジストリの追跡:** ツールレジストリは、サーバー名とそのツールの間のマッピングを維持します。

### 4. スキーマの処理

ツールパラメータスキーマは、Gemini API との互換性のためにサニタイズされます。

- **`$schema` プロパティ**は削除されます。
- **`additionalProperties`** は削除されます。
- **`default` を持つ `anyOf`** のデフォルト値は削除されます (Vertex AI との互換性)。
- **再帰的な処理**は、ネストされたスキーマに適用されます。

### 5. 接続管理

検出後:

- **永続的な接続:** ツールを正常に登録したサーバーは、接続を維持します。
- **クリーンアップ:** 使用可能なツールを提供しないサーバーの接続は閉じられます。
- **ステータスの更新:** 最終的なサーバーのステータスは `CONNECTED` または `DISCONNECTED` に設定されます。

## ツール実行フロー

Gemini モデルが MCP ツールの使用を決定すると、次の実行フローが発生します。

### 1. ツールの呼び出し

モデルは、次のものを含む `FunctionCall` を生成します。

- **ツール名:** 登録された名前 (プレフィックスが付加されている可能性があります)
- **引数:** ツールのパラメータスキーマに一致する JSON オブジェクト

### 2. 確認プロセス

各 `DiscoveredMCPTool` は、高度な確認ロジックを実装しています。

#### 信頼ベースのバイパス

```typescript
if (this.trust) {
  return false; // 確認は不要
}
```

#### 動的許可リスト

システムは、次の内部許可リストを維持します。

- **サーバーレベル:** `serverName` → このサーバーのすべてのツールが信頼されます。
- **ツールレベル:** `serverName.toolName` → この特定のツールが信頼されます。

#### ユーザーの選択の処理

確認が必要な場合、ユーザーは次のいずれかを選択できます。

- **一度だけ続行:** 今回のみ実行します。
- **このツールを常に許可:** ツールレベルの許可リストに追加します。
- **このサーバーを常に許可:** サーバーレベルの許可リストに追加します。
- **キャンセル:** 実行を中止します。

### 3. 実行

確認後 (または信頼によるバイパス後):

1. **パラメータの準備:** 引数はツールのスキーマに対して検証されます。
2. **MCP 呼び出し:** 基になる `CallableTool` は、次のものを使用してサーバーを呼び出します。

   ```typescript
   const functionCalls = [
     {
       name: this.serverToolName, // 元のサーバーツール名
       args: params,
     },
   ];
   ```

3. **応答の処理:** 結果は、LLM コンテキストとユーザー表示の両方のためにフォーマットされます。

### 4. 応答の処理

実行結果には次のものが含まれます。

- **`llmContent`:** 言語モデルのコンテキスト用の生の応答部分
- **`returnDisplay`:** ユーザー表示用にフォーマットされた出力 (多くの場合、マークダウンコードブロック内の JSON)

## MCP サーバーとの対話方法

### `/mcp` コマンドの使用

`/mcp` コマンドは、MCP サーバーのセットアップに関する包括的な情報を提供します。

```bash
/mcp
```

これにより、次のものが表示されます。

- **サーバーリスト:** 構成されているすべての MCP サーバー
- **接続ステータス:** `CONNECTED`、`CONNECTING`、または `DISCONNECTED`
- **サーバーの詳細:** 構成の概要 (機密データを除く)
- **利用可能なツール:** 各サーバーのツールのリストと説明
- **検出状態:** 全体的な検出プロセスのステータス

### `/mcp` 出力例

```
MCP サーバーのステータス:

📡 pythonTools (CONNECTED)
  コマンド: python -m my_mcp_server --port 8080
  作業ディレクトリ: ./mcp-servers/python
  タイムアウト: 15000ms
  ツール: calculate_sum, file_analyzer, data_processor

🔌 nodeServer (DISCONNECTED)
  コマンド: node dist/server.js --verbose
  エラー: 接続が拒否されました

🐳 dockerizedServer (CONNECTED)
  コマンド: docker run -i --rm -e API_KEY my-mcp-server:latest
  ツール: docker__deploy, docker__status

検出状態: COMPLETED
```

### ツールの使用法

検出されると、MCP ツールは組み込みツールのように Gemini モデルで利用可能になります。モデルは自動的に次のことを行います。

1. **適切なツールの選択:** リクエストに基づいて適切なツールを選択します。
2. **確認ダイアログの表示:** (サーバーが信頼されていない限り) 確認ダイアログを表示します。
3. **ツールの実行:** 適切なパラメータでツールを実行します。
4. **結果の表示:** ユーザーフレンドリーな形式で結果を表示します。

## ステータスの監視とトラブルシューティング

### 接続状態

MCP 統合は、いくつかの状態を追跡します。

#### サーバーのステータス (`MCPServerStatus`)

- **`DISCONNECTED`:** サーバーが接続されていないか、エラーがあります。
- **`CONNECTING`:** 接続試行中です。
- **`CONNECTED`:** サーバーが接続され、準備ができています。

#### 検出状態 (`MCPDiscoveryState`)

- **`NOT_STARTED`:** 検出は開始されていません。
- **`IN_PROGRESS`:** 現在サーバーを検出中です。
- **`COMPLETED`:** 検出が完了しました (エラーの有無にかかわらず)。

### 一般的な問題と解決策

#### サーバーが接続されない

**症状:** サーバーのステータスが `DISCONNECTED` と表示されます。

**トラブルシューティング:**

1. **構成の確認:** `command`、`args`、および `cwd` が正しいことを確認します。
2. **手動でのテスト:** サーバーコマンドを直接実行して、動作することを確認します。
3. **依存関係の確認:** 必要なすべてのパッケージがインストールされていることを確認します。
4. **ログの確認:** CLI 出力でエラーメッセージを探します。
5. **権限の確認:** CLI がサーバーコマンドを実行できることを確認します。

#### ツールが検出されない

**症状:** サーバーは接続されますが、ツールは利用できません。

**トラブルシューティング:**

1. **ツールの登録の確認:** サーバーが実際にツールを登録していることを確認します。
2. **MCP プロトコルの確認:** サーバーが MCP ツールの一覧表示を正しく実装していることを確認します。
3. **サーバーログの確認:** サーバー側のエラーについて stderr 出力を確認します。
4. **ツール一覧表示のテスト:** サーバーのツール検出エンドポイントを手動でテストします。

#### ツールが実行されない

**症状:** ツールは検出されますが、実行中に失敗します。

**トラブルシューティング:**

1. **パラメータの検証:** ツールが予期されるパラメータを受け入れることを確認します。
2. **スキーマの互換性:** 入力スキーマが有効な JSON スキーマであることを確認します。
3. **エラー処理:** ツールが未処理の例外をスローしていないかどうかを確認します。
4. **タイムアウトの問題:** `timeout` 設定を増やすことを検討してください。

#### サンドボックスの互換性

**症状:** サンドボックスが有効になっていると MCP サーバーが失敗します。

**解決策:**

1. **Docker ベースのサーバー:** すべての依存関係を含む Docker コンテナを使用します。
2. **パスのアクセシビリティ:** サーバーの実行可能ファイルがサンドボックスで利用可能であることを確認します。
3. **ネットワークアクセス:** 必要なネットワーク接続を許可するようにサンドボックスを構成します。
4. **環境変数:** 必要な環境変数が渡されていることを確認します。

### デバッグのヒント

1. **デバッグモードの有効化:** 詳細な出力を得るには、`--debug_mode` を付けて CLI を実行します。
2. **stderr の確認:** MCP サーバーの stderr がキャプチャされ、ログに記録されます (INFO メッセージはフィルタリングされます)。
3. **分離テスト:** 統合する前に、MCP サーバーを個別にテストします。
4. **段階的なセットアップ:** 複雑な機能を追加する前に、単純なツールから始めます。
5. **`/mcp` を頻繁に使用:** 開発中にサーバーのステータスを監視します。

## 重要な注意事項

### セキュリティに関する考慮事項

- **信頼設定:** `trust` オプションはすべての確認ダイアログをバイパスします。完全に制御しているサーバーに対してのみ慎重に使用してください。
- **アクセストークン:** API キーまたはトークンを含む環境変数を構成する場合は、セキュリティに注意してください。
- **サンドボックスの互換性:** サンドボックスを使用する場合は、MCP サーバーがサンドボックス環境内で利用可能であることを確認してください。
- **個人データ:** 広範囲にスコープが設定された個人用アクセストークンを使用すると、リポジトリ間で情報が漏洩する可能性があります。

### パフォーマンスとリソース管理

- **接続の永続性:** CLI は、ツールを正常に登録したサーバーへの永続的な接続を維持します。
- **自動クリーンアップ:** ツールを提供しないサーバーへの接続は自動的に閉じられます。
- **タイムアウト管理:** サーバーの応答特性に基づいて適切なタイムアウトを構成します。
- **リソース監視:** MCP サーバーは別のプロセスとして実行され、システムリソースを消費します。

### スキーマの互換性

- **プロパティの削除:** システムは、Gemini API との互換性のために特定のスキーマプロパティ (`$schema`、`additionalProperties`) を自動的に削除します。
- **名前のサニタイズ:** ツール名は、API の要件を満たすように自動的にサニタイズされます。
- **競合の解決:** サーバー間のツール名の競合は、自動プレフィックスによって解決されます。

この包括的な統合により、MCP サーバーは、セキュリティ、信頼性、使いやすさを維持しながら、Gemini CLI の機能を拡張するための強力な方法になります。