# Gemini CLI ファイルシステムツール

Gemini CLI は、ローカルファイルシステムと対話するための包括的なツールスイートを提供します。これらのツールを使用すると、Gemini モデルは、ユーザーの管理下で、通常は機密性の高い操作の確認を得て、ファイルの読み取り、書き込み、一覧表示、検索、変更を行うことができます。

**注:** すべてのファイルシステムツールは、セキュリティのために `rootDirectory` (通常は CLI を起動した現在の作業ディレクトリ) 内で動作します。これらのツールに指定するパスは、通常、絶対パスであるか、このルートディレクトリからの相対パスとして解決されることが想定されています。

## 1. `list_directory` (ReadFolder)

`list_directory` は、指定されたディレクトリパス内のファイルとサブディレクトリの名前を直接一覧表示します。指定された glob パターンに一致するエントリをオプションで無視できます。

- **ツール名:** `list_directory`
- **表示名:** ReadFolder
- **ファイル:** `ls.ts`
- **パラメータ:**
  - `path` (文字列、必須): 一覧表示するディレクトリへの絶対パス。
  - `ignore` (文字列の配列、任意): 一覧から除外する glob パターンのリスト (例: `["*.log", ".git"]`)。
  - `respect_git_ignore` (ブール値、任意): ファイルを一覧表示するときに `.gitignore` パターンを尊重するかどうか。デフォルトは `true` です。
- **動作:**
  - ファイルとディレクトリ名のリストを返します。
  - 各エントリがディレクトリであるかどうかを示します。
  - エントリをディレクトリを先に、次にアルファベット順に並べ替えます。
- **出力 (`llmContent`):** `/path/to/your/folder のディレクトリ一覧:\n[DIR] subfolder1\nfile1.txt\nfile2.png` のような文字列
- **確認:** いいえ。
- **ツール名:** `list_directory`
- **表示名:** ReadFolder
- **ファイル:** `ls.ts`
- **パラメータ:**
  - `path` (文字列、必須): 一覧表示するディレクトリへの絶対パス。
  - `ignore` (文字列の配列、任意): 一覧から除外する glob パターンのリスト (例: `["*.log", ".git"]`)。
  - `respect_git_ignore` (ブール値、任意): ファイルを一覧表示するときに `.gitignore` パターンを尊重するかどうか。デフォルトは `true` です。
- **動作:**
  - ファイルとディレクトリ名のリストを返します。
  - 各エントリがディレクトリであるかどうかを示します。
  - エントリをディレクトリを先に、次にアルファベット順に並べ替えます。
- **出力 (`llmContent`):** `/path/to/your/folder のディレクトリ一覧:\n[DIR] subfolder1\nfile1.txt\nfile2.png` のような文字列
- **確認:** いいえ。

## 2. `read_file` (ReadFile)

`read_file` は、指定されたファイルの内容を読み取って返します。このツールは、テキスト、画像 (PNG、JPG、GIF、WEBP、SVG、BMP)、および PDF ファイルを処理します。テキストファイルの場合、特定の行範囲を読み取ることができます。他のバイナリファイルタイプは通常スキップされます。

- **ツール名:** `read_file`
- **表示名:** ReadFile
- **ファイル:** `read-file.ts`
- **パラメータ:**
  - `path` (文字列、必須): 読み取るファイルへの絶対パス。
  - `offset` (数値、任意): テキストファイルの場合、読み取りを開始する 0 から始まる行番号。`limit` を設定する必要があります。
  - `limit` (数値、任意): テキストファイルの場合、読み取る最大行数。省略した場合、デフォルトの最大値 (例: 2000 行) またはファイル全体 (可能な場合) を読み取ります。
- **動作:**
  - テキストファイルの場合: 内容を返します。`offset` と `limit` を使用する場合、その行のスライスのみを返します。行制限または行長制限のために内容が切り捨てられたかどうかを示します。
  - 画像および PDF ファイルの場合: ファイルの内容を、モデルが消費するのに適した base64 エンコードされたデータ構造として返します。
  - 他のバイナリファイルの場合: それらを識別してスキップしようとし、それが一般的なバイナリファイルであることを示すメッセージを返します。
- **出力:** (`llmContent`):
  - テキストファイルの場合: ファイルの内容。切り捨てメッセージが前に付加される場合があります (例: `[ファイルの内容が切り捨てられました: 合計 500 行のうち 1 ～ 100 行を表示しています...]\n実際のファイルの内容...`)。
  - 画像/PDF ファイルの場合: `mimeType` と base64 `data` を含む `inlineData` を含むオブジェクト (例: `{ inlineData: { mimeType: 'image/png', data: 'base64encodedstring' } }`)。
  - 他のバイナリファイルの場合: `バイナリファイルの内容を表示できません: /path/to/data.bin` のようなメッセージ。
- **確認:** いいえ。
- **ツール名:** `read_file`
- **表示名:** ReadFile
- **ファイル:** `read-file.ts`
- **パラメータ:**
  - `path` (文字列、必須): 読み取るファイルへの絶対パス。
  - `offset` (数値、任意): テキストファイルの場合、読み取りを開始する 0 から始まる行番号。`limit` を設定する必要があります。
  - `limit` (数値、任意): テキストファイルの場合、読み取る最大行数。省略した場合、デフォルトの最大値 (例: 2000 行) またはファイル全体 (可能な場合) を読み取ります。
- **動作:**
  - テキストファイルの場合: 内容を返します。`offset` と `limit` を使用する場合、その行のスライスのみを返します。行制限または行長制限のために内容が切り捨てられたかどうかを示します。
  - 画像および PDF ファイルの場合: ファイルの内容を、モデルが消費するのに適した base64 エンコードされたデータ構造として返します。
  - 他のバイナリファイルの場合: それらを識別してスキップしようとし、それが一般的なバイナリファイルであることを示すメッセージを返します。
- **出力:** (`llmContent`):
  - テキストファイルの場合: ファイルの内容。切り捨てメッセージが前に付加される場合があります (例: `[ファイルの内容が切り捨てられました: 合計 500 行のうち 1 ～ 100 行を表示しています...]\n実際のファイルの内容...`)。
  - 画像/PDF ファイルの場合: `mimeType` と base64 `data` を含む `inlineData` を含むオブジェクト (例: `{ inlineData: { mimeType: 'image/png', data: 'base64encodedstring' } }`)。
  - 他のバイナリファイルの場合: `バイナリファイルの内容を表示できません: /path/to/data.bin` のようなメッセージ。
- **確認:** いいえ。

## 3. `write_file` (WriteFile)

`write_file` は、指定されたファイルに内容を書き込みます。ファイルが存在する場合、上書きされます。ファイルが存在しない場合、そのファイル (および必要な親ディレクトリ) が作成されます。

- **ツール名:** `write_file`
- **表示名:** WriteFile
- **ファイル:** `write-file.ts`
- **パラメータ:**
  - `file_path` (文字列、必須): 書き込むファイルへの絶対パス。
  - `content` (文字列、必須): ファイルに書き込む内容。
- **動作:**
  - 指定された `content` を `file_path` に書き込みます。
  - 親ディレクトリが存在しない場合は作成します。
- **出力 (`llmContent`):** `ファイルの上書きに成功しました: /path/to/your/file.txt` または `新しいファイルの作成と書き込みに成功しました: /path/to/new/file.txt` などの成功メッセージ。
- **確認:** はい。変更の差分を表示し、書き込む前にユーザーの承認を求めます。
- **ツール名:** `write_file`
- **表示名:** WriteFile
- **ファイル:** `write-file.ts`
- **パラメータ:**
  - `file_path` (文字列、必須): 書き込むファイルへの絶対パス。
  - `content` (文字列、必須): ファイルに書き込む内容。
- **動作:**
  - 指定された `content` を `file_path` に書き込みます。
  - 親ディレクトリが存在しない場合は作成します。
- **出力 (`llmContent`):** `ファイルの上書きに成功しました: /path/to/your/file.txt` または `新しいファイルの作成と書き込みに成功しました: /path/to/new/file.txt` などの成功メッセージ。
- **確認:** はい。変更の差分を表示し、書き込む前にユーザーの承認を求めます。

## 4. `glob` (FindFiles)

`glob` は、特定の glob パターン (例: `src/**/*.ts`、`*.md`) に一致するファイルを検索し、変更時刻 (新しい順) でソートされた絶対パスを返します。

- **ツール名:** `glob`
- **表示名:** FindFiles
- **ファイル:** `glob.ts`
- **パラメータ:**
  - `pattern` (文字列、必須): 一致させる glob パターン (例: `"*.py"`、`"src/**/*.js"`)。
  - `path` (文字列、任意): 検索するディレクトリへの絶対パス。省略した場合、ツールのルートディレクトリを検索します。
  - `case_sensitive` (ブール値、任意): 検索で大文字と小文字を区別するかどうか。デフォルトは `false` です。
  - `respect_git_ignore` (ブール値、任意): ファイルを検索するときに .gitignore パターンを尊重するかどうか。デフォルトは `true` です。
- **動作:**
  - 指定されたディレクトリ内で glob パターンに一致するファイルを検索します。
  - 最近変更されたファイルが先頭になるようにソートされた絶対パスのリストを返します。
  - `node_modules` や `.git` などの一般的な迷惑なディレクトリはデフォルトで無視します。
- **出力 (`llmContent`):** `src 内で "*.ts" に一致する 5 個のファイルが見つかりました。変更時刻 (新しい順) でソートされています:\nsrc/file1.ts\nsrc/subdir/file2.ts...` のようなメッセージ
- **確認:** いいえ。
- **ツール名:** `glob`
- **表示名:** FindFiles
- **ファイル:** `glob.ts`
- **パラメータ:**
  - `pattern` (文字列、必須): 一致させる glob パターン (例: `"*.py"`、`"src/**/*.js"`)。
  - `path` (文字列、任意): 検索するディレクトリへの絶対パス。省略した場合、ツールのルートディレクトリを検索します。
  - `case_sensitive` (ブール値、任意): 検索で大文字と小文字を区別するかどうか。デフォルトは `false` です。
  - `respect_git_ignore` (ブール値、任意): ファイルを検索するときに .gitignore パターンを尊重するかどうか。デフォルトは `true` です。
- **動作:**
  - 指定されたディレクトリ内で glob パターンに一致するファイルを検索します。
  - 最近変更されたファイルが先頭になるようにソートされた絶対パスのリストを返します。
  - `node_modules` や `.git` などの一般的な迷惑なディレクトリはデフォルトで無視します。
- **出力 (`llmContent`):** `src 内で "*.ts" に一致する 5 個のファイルが見つかりました。変更時刻 (新しい順) でソートされています:\nsrc/file1.ts\nsrc/subdir/file2.ts...` のようなメッセージ
- **確認:** いいえ。

## 5. `search_file_content` (SearchText)

`search_file_content` は、指定されたディレクトリ内のファイルの内容で正規表現パターンを検索します。glob パターンでファイルをフィルタリングできます。一致する行を、そのファイルパスと行番号とともに返します。

- **ツール名:** `search_file_content`
- **表示名:** SearchText
- **ファイル:** `grep.ts`
- **パラメータ:**
  - `pattern` (文字列、必須): 検索する正規表現 (regex) (例: `"function\s+myFunction"`)。
  - `path` (文字列、任意): 検索するディレクトリへの絶対パス。デフォルトは現在の作業ディレクトリです。
  - `include` (文字列、任意): 検索するファイルをフィルタリングする glob パターン (例: `"*.js"`、`"src/**/*.{ts,tsx}"`)。省略した場合、ほとんどのファイルが検索されます (一般的な無視を尊重します)。
- **動作:**
  - Git リポジトリで利用可能な場合は速度のために `git grep` を使用し、それ以外の場合はシステムの `grep` または JavaScript ベースの検索にフォールバックします。
  - 一致する行のリストを返します。各行には、そのファイルパス (検索ディレクトリからの相対パス) と行番号が前に付加されます。
- **出力 (`llmContent`):** 一致のフォーマットされた文字列。例:
- **ツール名:** `search_file_content`
- **表示名:** SearchText
- **ファイル:** `grep.ts`
- **パラメータ:**
  - `pattern` (文字列、必須): 検索する正規表現 (regex) (例: `"function\s+myFunction"`)。
  - `path` (文字列、任意): 検索するディレクトリへの絶対パス。デフォルトは現在の作業ディレクトリです。
  - `include` (文字列、任意): 検索するファイルをフィルタリングする glob パターン (例: `"*.js"`、`"src/**/*.{ts,tsx}"`)。省略した場合、ほとんどのファイルが検索されます (一般的な無視を尊重します)。
- **動作:**
  - Git リポジトリで利用可能な場合は速度のために `git grep` を使用し、それ以外の場合はシステムの `grep` または JavaScript ベースの検索にフォールバックします。
  - 一致する行のリストを返します。各行には、そのファイルパス (検索ディレクトリからの相対パス) と行番号が前に付加されます。
- **出力 (`llmContent`):** 一致のフォーマットされた文字列。例:
  ```
  パス "." (フィルター: "*.ts") でパターン "myFunction" に 3 件一致しました:
  ---
  ファイル: src/utils.ts
  L15: export function myFunction() {
  L22:   myFunction.call();
  ---
  ファイル: src/index.ts
  L5: import { myFunction } from './utils';
  ---
  ```
- **確認:** いいえ。
- **確認:** いいえ。

## 6. `replace` (編集)

`replace` はファイル内のテキストを置換します。デフォルトでは 1 つの出現箇所を置換しますが、`expected_replacements` を指定すると複数の出現箇所を置換できます。このツールは、正確で的を絞った変更を行うように設計されており、正しい場所を変更するために `old_string` の周囲にかなりのコンテキストが必要です。

- **ツール名:** `replace`
- **表示名:** 編集
- **ファイル:** `edit.ts`
- **パラメータ:**

  - `file_path` (文字列、必須): 変更するファイルへの絶対パス。
  - `old_string` (文字列、必須): 置換する正確なリテラルテキスト。

    **重要:** この文字列は、変更する単一のインスタンスを一意に識別する必要があります。対象のテキストの _前_ と _後_ に少なくとも 3 行のコンテキストを含め、空白とインデントを正確に一致させる必要があります。`old_string` が空の場合、ツールは `new_string` をコンテンツとして `file_path` に新しいファイルを作成しようとします。

  - `new_string` (文字列、必須): `old_string` を置換する正確なリテラルテキスト。
  - `expected_replacements` (数値、任意): 置換する出現箇所の数。デフォルトは `1` です。

- **動作:**
  - `old_string` が空で `file_path` が存在しない場合、`new_string` をコンテンツとして新しいファイルを作成します。
  - `old_string` が指定されている場合、`file_path` を読み取り、`old_string` の出現箇所を 1 つだけ見つけようとします。
  - 1 つの出現箇所が見つかった場合、それを `new_string` に置き換えます。
  - **信頼性の向上 (多段階編集修正):** 特にモデルが提供する `old_string` が完全に正確でない場合に編集の成功率を大幅に向上させるために、ツールには多段階編集修正メカニズムが組み込まれています。
  - 初期の `old_string` が見つからないか、複数の場所に一致する場合、ツールは Gemini モデルを活用して `old_string` (および場合によっては `new_string`) を繰り返し絞り込むことができます。
  - この自己修正プロセスは、モデルが変更しようとした一意のセグメントを特定しようとし、わずかに不完全な初期コンテキストでも `replace` 操作をより堅牢にします。
- **失敗条件:** 修正メカニズムにもかかわらず、次の場合にツールは失敗します。
  - `file_path` が絶対パスでないか、ルートディレクトリの外にある。
  - `old_string` は空ではないが、`file_path` が存在しない。
  - `old_string` は空だが、`file_path` が既に存在する。
  - 修正を試みた後、ファイル内で `old_string` が見つからない。
  - `old_string` が複数回見つかり、自己修正メカニズムがそれを単一の明確な一致に解決できない。
- **出力 (`llmContent`):**
  - 成功時: `ファイルの変更に成功しました: /path/to/file.txt (1 件の置換)` または `指定されたコンテンツで新しいファイルを作成しました: /path/to/new_file.txt`
  - 失敗時: 理由を説明するエラーメッセージ (例: `編集に失敗しました、0 件の出現箇所が見つかりました...`、`編集に失敗しました、1 件の出現箇所が期待されていましたが 2 件見つかりました...`)。
- **確認:** はい。提案された変更の差分を表示し、ファイルに書き込む前にユーザーの承認を求めます。

  - `new_string` (文字列、必須): `old_string` を置換する正確なリテラルテキスト。
  - `expected_replacements` (数値、任意): 置換する出現箇所の数。デフォルトは `1` です。

- **動作:**
  - `old_string` が空で `file_path` が存在しない場合、`new_string` をコンテンツとして新しいファイルを作成します。
  - `old_string` が指定されている場合、`file_path` を読み取り、`old_string` の出現箇所を 1 つだけ見つけようとします。
  - 1 つの出現箇所が見つかった場合、それを `new_string` に置き換えます。
  - **信頼性の向上 (多段階編集修正):** 特にモデルが提供する `old_string` が完全に正確でない場合に編集の成功率を大幅に向上させるために、ツールには多段階編集修正メカニズムが組み込まれています。
    - 初期の `old_string` が見つからないか、複数の場所に一致する場合、ツールは Gemini モデルを活用して `old_string` (および場合によっては `new_string`) を繰り返し絞り込むことができます。
    - この自己修正プロセスは、モデルが変更しようとした一意のセグメントを特定しようとし、わずかに不完全な初期コンテキストでも `replace` 操作をより堅牢にします。
- **失敗条件:** 修正メカニズムにもかかわらず、次の場合にツールは失敗します。
  - `file_path` が絶対パスでないか、ルートディレクトリの外にある。
  - `old_string` は空ではないが、`file_path` が存在しない。
  - `old_string` は空だが、`file_path` が既に存在する。
  - 修正を試みた後、ファイル内で `old_string` が見つからない。
  - `old_string` が複数回見つかり、自己修正メカニズムがそれを単一の明確な一致に解決できない。
- **出力 (`llmContent`):**
  - 成功時: `ファイルの変更に成功しました: /path/to/file.txt (1 件の置換)` または `指定されたコンテンツで新しいファイルを作成しました: /path/to/new_file.txt`
  - 失敗時: 理由を説明するエラーメッセージ (例: `編集に失敗しました、0 件の出現箇所が見つかりました...`、`編集に失敗しました、1 件の出現箇所が期待されていましたが 2 件見つかりました...`)。
- **確認:** はい。提案された変更の差分を表示し、ファイルに書き込む前にユーザーの承認を求めます。

これらのファイルシステムツールは、Gemini CLI がローカルのプロジェクトコンテキストを理解し、対話するための基盤を提供します。